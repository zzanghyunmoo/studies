# 프로그래밍 언어의 분류

## 저수준 언어 vs 고수준 언어

| 저수준 언어 | 고수준 언어 |
| :-- | :-- |
| 컴퓨터가 이해하기 쉬운 언어 | 인간이 이해하기 쉬운 언어 |
| 0, 1로만 이루어짐 | 인간이 사용하는 언어로 이루어짐 |
| 기계어 | 어셈블리어, C, C++, C# |
| 컴퓨터가 바로 이해하므로 변환 과정이 필요 없음 | 컴퓨터가 이해하는 기계어로 변환하는 과정이 필요 |


### 컴퓨터가 이해하는 것.

컴퓨터가 이해하는 것은 오로지 0,1 밖에 없음. 컴퓨터는 2진수로 구성된 명령어 셋을 이해하는 것임. 그래서 기계어 혹은 네이티브 코드라고 말함. 

모든 프로그래밍 언어는 결과적으로 기계어로 번역이 되어야 실행이 될 수 있음.

다만 사람이 이를 이해하기는 정말 어려운 작업임. 그래서 보다 사람에게 친근한 방법으로 "어셈블리" 언어가 만들어짐.

```assembly
MOV R1, 3   # R1에 3을 저장해
MOV R2, 4   # R2에 4를 저장해
ADD R1, R2  # R1, R2를 더한 후, R1에 저장해, R1 = 7 (3 + 4)
MUL R1, R2  # R1, R2를 곱한 후, R1에 저장해, R1= 28 (7 * 4)
```

하지만, 프로그램 규모가 더 커질수록 더 복잡한 코드를 쉽게 이해하고 작성할 수 있는 방법이 필요해짐. 그래서 만들어진게 "C"언어 같은 고수준 프로그래밍 언어임.

```c
int r1 = 3;
int r2 = 4;
r1 = r1 + r2;
r1 = r1 * r2;
```

고수준 프로그래밍 언어도, 메모리를 누가 관리하느냐에 따라서 매니지드 언어, 언매니지드 언어로 나뉨.

## 컴파일 언어, 인터프리터 언어

실행을 어떤 단계를 거쳐서 하느냐의 차이임.

* 컴파일 언어: 소스 코드 -> 컴파일러 -> 기계어 -> 실행 
  * 컴파일러는 소스코드를 기계어로 변환하는 역할을 한다.
  * 대표적으로 C, C++, Rust 가 있음.
  * 다양한 최적화 가능
  * 플랫폼마다 실행 파일을 만들기 위해서, 각각 컴파일이 필요함.
* JIT 컴파일 언어: 소스 코드 -> 컴파일러 -> 중간 언어 -> JIT 컴파일러 (가상 머신) -> 기계어 -> 실행
  * 대표적으로 C#, Java이 있음.
  * 가상머신(VM)이 중간 언어를 해석해서 기계어로 변환 
  * 플랫폼 별로 VM을 설치해야 함.
  * 프로그램 실행 중에 VM이 중간 언어를 기계가 이해하는 언어로 바꿔서 실행.
* 인터프리터 언어: 소스 코드 -> 인터프리터 (--> 기계어) -> 실행
  * 대표적으로 Python, Javascript가 있음.
  * 인터프리터가 소스코드를 한 줄 한 줄 읽어서 기계어로 변환하여 실행.
  * 실제로 실행하기 전까지 코드의 문제를 잡아낼 수 없다는 단점이 있음.
  
## 강한 타입 언어, 약한 타입 언어

변수 선언과 관련이 있음. 변수를 선언한 후에 타입을 변경할 수 있는지 여부.

* 약한 타입 언어: 변수 선언 후 타입 변경이 가능함, Python, JS가 이에 해당
* 강한 타입 언어: 변수 선언 후 타입 변경이 불간으함. C, C++이 이에 해당. (C#은 약한 타입 지원함.)

약한 타입 언어는 실제로 코드를 실행하기 전까지 실수를 찾을 수 없다는 치명적인 단점이 생김.

## 매니지드 언어, 언매니지드 언어

누가 메모리의 라이프 사이클을 관리하느냐가 핵심.

* 언매니지드 언어: 프로그래머가 책임지고 메모리를 반환함, 예: C, C++, Rust
  * 성능을 극한까지 이끌어낼 수 있음.
  * 다만 제대로 반납하지 않으면 메모리 릭 이슈가 발생함.
* 매니지드 언어: 프로그래밍 언어가 더 이상 사용하지 않는 메모리를 반환함, 예: C#, Java, Golang
  * 실수가 적고 편함.
  * 성능을 극한까지 끌어내는 작업에는 사용하기 어려움.

언매니지드 언어를 꼭 배워야 하는 이유?

아래의 것들을 이해할 수 있음.

* 메모리 동작 원리
* CPU 동작 원리
* 컴퓨터처럼 생각하는 방법
* 매니지드 언어에서 지원하는 모든 마법같은 기능들의 동작 원리

이른 시기에 컴퓨터처럼 생각하는 습관을 들이면 그러지 못한 사람들보다 빠르게 성장할 것임.

## 프로그래밍 패러다임: 절차적 언어

가장 단순한 형태의 언어. 순차적으로 함수를 실행하여 결과를 얻는다. 기능과 자료저장의 분리가 핵심. 상태가 변할 수 있다를 유의해야 함.

```c
#include <stdio.h>

int gSum = 0;

void Accumulate(int sum) {
  gSum += sum;
}

int main() {
  int num = 0;

  printf("Enter a number: ");
  scanf("%d", &num);
  Accumulate(num);

  printf("Sum after adding %d is %d\n", num, gSum);  
  return 0;
}
```

## 프로그래밍 패러다임: OOP 언어

개체(Object) 지향 프로그래밍. 현재 있는 패러다임 중 가장 널리 쓰이는 패러다임임. 절차 지향은 기계 위주로 돌았던 프로그래밍 언어를 사람한테 직관적인 개념을 프로그래밍 언어를 만든 것.

기능과 자료를 하나의 개체에 합침.

Student.cs
```c#
namespace CSharpExample
{
  public class Student
  {
    // 상태
    public string Name { get; private set; }
    public string ID { get; private set; }

    public Student(string name, string id)
    {
      Name = name;
      ID = id;
    }

    // 기능
    public bool TryChangeName(string name)
    {
      if (Name != name)
      {
        Name = name;
        return true;
      }

      return false;
    }
  }
}
```

Program.cs
```c#
using System;

namespace CSharpExample
{
  class Program
  {
    static void main(string[] args)
    {
      Student s = new Student("Pope Kim", "a123456");
      s.TryChangeName("Babo Kim");
      Console.WriteLine("Student Name: {0} ID: {1}". s.Name, s.ID);
    }
  }
}
```

## 프로그래밍 패러다임: 함수형 언어

함수가 있지만, 상태의 변화가 없음. 즉 불변성이 핵심임. 동시성 같은 환경에서 주로 많이 사용하는 패러다임임.

```f#
(defun add (n1 n2)
  (+ n1 n2))
(write(add 10 20))
```

## C#은 어떤 언어인가요?

C#은 다음과 같은 특징을 가지고 있음.

* 강타입 언어
* 매니지드 언어
* OOP
